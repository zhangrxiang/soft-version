package soft

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"gopkg.in/alecthomas/kingpin.v2"
	"io"
	"os"
	"path"
	"runtime"
	"strings"
	"time"
)

type Command struct {
	App                 *kingpin.Application
	Soft                Soft
	runCallback         func()
	beforeParseCallback func()
}

func NewCommand() *Command {
	s := *NewSoft()
	str, err := Md5FileStr()
	if err != nil {
		fmt.Println("md5", err)
	}
	s.Version.hash = str
	return &Command{
		Soft: s,
	}
}

func (c *Command) BeforeParseCallback(callback func()) *Command {
	c.runCallback = callback
	return c
}

func (c *Command) RunCallback(callback func()) *Command {
	c.runCallback = callback
	return c
}

func (c *Command) Parse() {
	c.App = kingpin.New(c.Soft.Name, c.Soft.Author)
	if c.beforeParseCallback != nil {
		c.beforeParseCallback()
	}
	c.App.Command("run", fmt.Sprintf("运行%s", c.Soft.Name)).Action(func(context *kingpin.ParseContext) error {
		if c.runCallback == nil {
			return errors.New("软件没有回调运行程序函数")
		}
		c.runCallback()
		return nil
	})
	c.App.Command("version", fmt.Sprintf("%s版本", c.Soft.Name)).Action(func(context *kingpin.ParseContext) error {
		fmt.Println(c.Soft.SimpleVersion())
		return nil
	})
	c.App.Command("full-version", fmt.Sprintf("%s版本全称", c.Soft.Name)).Action(func(context *kingpin.ParseContext) error {
		fmt.Println(c.Soft.FullVersion())
		return nil
	})
	c.App.Command("info", fmt.Sprintf("%s版本信息", c.Soft.Name)).Action(func(context *kingpin.ParseContext) error {
		fmt.Println(c.Soft.Info())
		return nil
	})

	c.App.Command("build", "开发编译[软件开发者专用]").Action(build)
	c.App.Command("init", "初始化软件版本配置文件[软件开发者专用]").Action(initJson)
	kingpin.MustParse(c.App.Parse(os.Args[1:]))
}

//配置文件初始化
func initJson(_ *kingpin.ParseContext) error {
	_, err := os.Open("version.json")
	if os.IsNotExist(err) {
		file, err := os.Create("version.json")
		if err != nil {
			return errors.New("创建版本配置文件失败")
		}
		soft := &Soft{
			Name:   "xx-软件",
			Alias:  "别名",
			Author: "作者",
			Version: Version{
				Version: "0.0.1",
				Log:     "init",
				Status:  Base,
			},
			Copyright: "All rights reserved",
			Inherit:   true,
		}
		content, err := json.MarshalIndent(soft, "", "  ")
		if err != nil {
			return errors.New("")
		}
		_, err = file.Write(content)
		if err != nil {
			return errors.New("写入版本配置文件失败")
		}
		fmt.Println("初始化版本控制文件成功")
		return err
	}
	return errors.New("版本配置文件已经存在")
}

//构建
func build(_ *kingpin.ParseContext) error {
	file, err := os.Open("version.json")
	if err != nil {
		return errors.New("无版本配置文件")
	}
	reader := bufio.NewReader(file)
	var content = make([]byte, reader.Size())
	total, err := reader.Read(content)
	if err != nil {
		return errors.New("读取配置文件失败")
	}
	soft := &Soft{}
	err = json.Unmarshal(content[:total], soft)
	if err != nil {
		return errors.New("unmarshal " + err.Error())
	}
	soft.Version.updatedAt = time.Now().Format("2006.01.02 15:04:05")
	_, f, _, ok := runtime.Caller(0)
	if !ok {
		return errors.New("caller err")
	}
	file, err = os.Create(path.Dir(f) + "/auto_generate.go")
	if err != nil {
		return errors.New("Create " + err.Error())
	}
	if file != nil {
		_, err := file.Seek(0, io.SeekStart)
		if err != nil {
			return errors.New("Seek " + err.Error())
		}
		c := `// Code generated by Soft build; DO NOT EDIT.
package Soft

func NewSoft() *Soft {
	s := &Soft{}
	return s
}
`
		c = strings.Replace(c, "&Soft{}", soft.JSON(), -1)
		_, err = file.Write([]byte(c))
		if err != nil {
			return errors.New("写入文件失败")
		}
		fmt.Println("保存文件成功")
	}
	return nil
}
